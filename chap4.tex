
\chapter{基于关键点重投影误差优化的6D姿态解算方法}
\label{chap:RANSAC-TRO-SQPnP}

\section{引言}
\label{sec:RANSAC-TRO-SQPnP:intro}
在上一章中，已针对单张图像的关键点检测进行了研究，并利用基于注意力机制的关键点检测网络成功获取了非合作目标关键点在图像中的像素坐标。为了从这些像素坐标中精确计算出空间非合作目标的 6D 姿态，需要将这些像素坐标与非合作目标先验的标准 6D 姿态下的关键点的 3D 坐标结合，通过求解PnP问题进而得出空间非合作目标的完整6D姿态。现有研究中，大多数工作采用P3P\cite{chen2019satellite,s22218541,Guo_2022}或 EPnP\cite{li2022learning,huan2020pose,lotti2022investigating}等算法进行求解。

然而，上一章所提出的关键点检测模型预测的关键点像素坐标不可避免地存在一定的噪声，这种噪声的存在使得任意 6D 姿态参数（包括 6D 真值下预测出的关键点的重投影误差）都不可能为0。特别是在目标截断、光照不足、光照过亮、背景干扰等极端条件下，这种噪声会显著增大。

与此同时，现有的基于几何和迭代求解的PnP算法（如 P3P 和 EPnP 等）在面对较大噪声或明显的异常点时，往往难以保持高精度与稳定性。具体而言，P3P 需要在多次假设-检验的框架下对多重候选解进行评估，一旦存在较大噪声或异常点，算法易出现较多的错误候选解，从而增加求解难度；而EPnP虽然在较多关键点时具有一定的鲁棒性，但在关键点数量有限、噪声偏大或关键点检测质量较差的情况下，也会面临退化问题，容易陷入局部最优解或者出现不收敛的情况。

为更有效地应对 PnP 求解过程中关键点检测网络预测出的较大噪声，本章采用了 George Terzakis 和 Manolis Lourakis 提出的一种基于重投影误差优化的求解方案 SQPnP\cite{terzakis2020consistently}。该方法能够在关键点存在较大噪声的情况下，仍然保持较高的姿态估计精度。

考虑到在极端场景中，关键点检测模型可能产生一定比例的异常点，这些异常点会对估计结果的精度造成显著影响。为了解决这一问题，本章引入了 RANSAC 算法，通过随机选取关键点子集输入 SQPnP，并选择重投影误差最小的子集作为内点，从而有效排除异常点的干扰，提高姿态估计的鲁棒性。

然而SQPnP 算法以优化旋转矩阵$R$为核心，而平移向量$t$的估计则是基于$R$求解得出，这导致$t$与$R$之间存在一定程度的耦合，可能会对最终优化收敛产生不利影响。针对这一问题，本章在 RANSAC-SQPnP 求解的结果基础上，进一步引入信赖域优化（Trust Region Optimization，TRO）方法，通过对旋转和平移参数进行解耦和精细优化，最终使得结果收敛到更高精度。

基于上述分析，本章提出并详细研究了一种结合 RANSAC、SQPnP和信赖域优化的 PnP 求解算法，称为 RANSAC-TRO-SQPnP。该算法通过充分结合了优化算法的处理思路与迭代框架，有效应对了实际应用中面临的多重挑战。具体而言，RANSAC 组件负责识别并剔除异常点，提高算法的鲁棒性；SQPnP 组件提供对关键点噪声的适应能力，保证基础姿态估计的准确性；而 TRO 算法则对初步估计的 6D 姿态进行局部精细优化，解决旋转与平移参数的耦合问题。实验结果表明，所提出的 RANSAC-TRO-SQPnP 方法能够显著提高非合作目标 6D 姿态估计的精度和鲁棒性，特别是在关键点检测存在较大噪声和异常点的复杂场景中表现出色。



\section{基于 SQPnP 的 PnP 问题求解}
\label{sec:RANSAC-TRO-SQPnP:SQPnP}

在空间非合作目标 6D 姿态测量中，经常使用的算法有 EPnP、P3P。然而，由于关键点检测网络得到的关键点通常存在一定噪声，传统几何与代数解法（如 EPnP、P3P）在此情况下的鲁棒性相对不足。相比之下，SQPnP 算法\cite{terzakis2020consistently}直接以关键点重投影误差最小化为核心思路，通过构建恰当的优化模型并利用序列二次规划进行迭代求解。不同于 LM、GN 等优化方法依赖外部的初始值，它是自己完成初始值计算并在此基础上进行优化。




\subsection{SQPnP 优化问题建模}
PnP问题可表述为：给定 $n$ 对空间点和图像点的对应关系，求解相机的旋转矩阵 $R$ 和平移向量 $\mathbf{t}$。这里可以将其转化为一个带约束的优化问题，即在保证 $R$ 为正交矩阵的条件下最小化关键点重投影误差的平方和。令旋转矩阵 $R$ 的 9 个元素按行（或列）展开组成向量 $\mathbf{x}\in\mathbb{R}^9$，那么优化目标可表示为一个关于 $\mathbf{x}$ 的二次型，而正交性条件则转化为 $\mathbf{x}$ 满足的约束方程组。具体地，消去平移 $\mathbf{t}$ 后得到的代价函数可写成：
\begin{equation}
	\min_{\mathbf{x}\in\mathbb{R}^9}\;
	\mathbf{x}^{\top}\Omega\mathbf{x}
	\quad\text{s.t.}\quad
	h(\mathbf{x})=\mathbf{0}_6
\end{equation}

其中 $\Omega$ 是由观测数据计算得到的 $9\times9$ 宽松正定矩阵。  
$h(\mathbf{x})=\mathbf{0}_6$ 表示一组等式约束，当 $h(\mathbf{x})=\mathbf{0}_6$ 时，$\mathbf{x}$ 恰好对应一个旋转矩阵。若记
\begin{equation}
	\mathbf{x}=
	\begin{bmatrix}
		\mathbf{r}_{1:3}\\[2pt]
		\mathbf{r}_{4:6}\\[2pt]
		\mathbf{r}_{7:9}
	\end{bmatrix}
	\quad
	\text{(其中每个 }\mathbf{r}_{i:i+2}\in\mathbb{R}^3\text{)}
\end{equation}
则可写出正交性约束：
\begin{equation}
	h(\mathbf{x})=
	\begin{bmatrix}
		\mathbf{r}_{1:3}^{\top}\mathbf{r}_{1:3}-1\\
		\mathbf{r}_{4:6}^{\top}\mathbf{r}_{4:6}-1\\
		\mathbf{r}_{7:9}^{\top}\mathbf{r}_{7:9}-1\\
		\mathbf{r}_{1:3}^{\top}\mathbf{r}_{4:6}\\
		\mathbf{r}_{1:3}^{\top}\mathbf{r}_{7:9}\\
		\mathbf{r}_{4:6}^{\top}\mathbf{r}_{7:9}
	\end{bmatrix}
	=\mathbf{0}_6
\end{equation}

\subsection{SQPnP旋转矩阵 $R$ 的求解}
采用序列二次规划（Sequential Quadratic Programming, SQP）方法来求解上述带约束的非线性二次规划问题。SQP 的核心思想是：在迭代的每一步，将当前问题在附近用二次函数近似其目标函数、并用线性函数近似其约束条件，从而形成一个线性约束的二次规划（Linearly Constrained Quadratic Program，LCQP）子问题。通过求解该子问题可以得到原问题的一个改进解，如此迭代直至收敛。对于 PnP 问题，由于目标函数可以转化成二次型（$\mathbf{x}^\top \Omega \mathbf{x}$），因此在 $R$ 的当前估计值附近，其二次近似就是自身；而约束的线性化则来自对正交性约束 $h(\mathbf{x})=\mathbf{0}$ 做一阶泰勒展开。具体来说，设第 $k$ 次迭代的当前解为 $\mathbf{x}^{(k)}=\mathbf{r}^{(k)}$（对应旋转矩阵 $R^{(k)}$），则令增量 $\boldsymbol{\delta}= \mathbf{x}-\mathbf{r}^{(k)}$。目标函数关于 $\boldsymbol{\delta}$ 的展开为：
\begin{equation}
	f\bigl(\mathbf{r}^{(k)}+\boldsymbol{\delta}\bigr)
	= \bigl(\mathbf{r}^{(k)}+\boldsymbol{\delta}\bigr)^{\!\top}\!\Omega\bigl(\mathbf{r}^{(k)}+\boldsymbol{\delta}\bigr)
	= \mathbf{r}^{(k)\top}\!\Omega\,\mathbf{r}^{(k)}
	+ 2\,\mathbf{r}^{(k)\top}\!\Omega\,\boldsymbol{\delta}
	+ \boldsymbol{\delta}^{\top}\!\Omega\,\boldsymbol{\delta}
\end{equation}
其中常数项 $\mathbf{r}^{(k)\top}\!\Omega\,\mathbf{r}^{(k)}$ 可略去。约束函数的线性化为：
\begin{equation}
	h\bigl(\mathbf{r}^{(k)}+\boldsymbol{\delta}\bigr)
	\approx
	h\bigl(\mathbf{r}^{(k)}\bigr)
	+ \mathbf{H}_{\mathbf{r}^{(k)}}\,\boldsymbol{\delta}
	= \mathbf{0}_6
\end{equation}
其中 $\mathbf{H}_{\mathbf{r}^{(k)}}=\left.\tfrac{\partial h}{\partial \mathbf{x}}\right|_{\mathbf{x}=\mathbf{r}^{(k)}}$ 是在当前点计算的 $6\times9$ 雅可比矩阵。若当前解 $\mathbf{r}^{(k)}$ 已满足约束（即 $h(\mathbf{r}^{(k)})=\mathbf{0}$，例如选择初始解时取满足 $R^\top R=I$ 的矩阵），则线性化可简化为
\begin{equation}
	\mathbf{H}_{\mathbf{r}^{(k)}}\,\boldsymbol{\delta}= \mathbf{0}\;
\end{equation}
即使 $\mathbf{r}^{(k)}$ 初始不完全可行，线性约束
\begin{equation}
	\mathbf{H}_{\mathbf{r}^{(k)}}\,\boldsymbol{\delta}= -\,h\bigl(\mathbf{r}^{(k)}\bigr)
\end{equation}
也会逐步将解拉回可行域。这样，第 $k$ 步迭代的局部子问题可表述为：
\begin{equation}
	\min_{\boldsymbol{\delta}\in\mathbb{R}^9}\;
	\boldsymbol{\delta}^{\top}\!\Omega\,\boldsymbol{\delta}
	+ 2\,\mathbf{r}^{(k)\top}\!\Omega\,\boldsymbol{\delta}
	\quad
	\text{s.t.}\;
	\mathbf{H}_{\mathbf{r}^{(k)}}\,\boldsymbol{\delta}= -\,h\bigl(\mathbf{r}^{(k)}\bigr)
\end{equation}

这是一个带线性等式约束的凸二次优化问题。可以通过拉格朗日乘子条件将其转化为线性方程组求解。构建拉格朗日函数
\begin{equation}
	\mathcal{L}\!\bigl(\boldsymbol{\delta},\boldsymbol{\lambda}\bigr)
	= \boldsymbol{\delta}^{\top}\!\Omega\,\boldsymbol{\delta}
	+ 2\,\mathbf{r}^{(k)\top}\!\Omega\,\boldsymbol{\delta}
	+ \boldsymbol{\lambda}^{\top}\!\Bigl(\mathbf{H}_{\mathbf{r}^{(k)}}\,\boldsymbol{\delta}
	+ h\bigl(\mathbf{r}^{(k)}\bigr)\Bigr)
\end{equation}
对 $\boldsymbol{\delta}$ 和拉格朗日乘子向量 $\boldsymbol{\lambda}$ 求导并令其为零，即可得到 KKT 条件所对应的线性方程组：
\begin{equation}
	\begin{pmatrix}
		2\Omega & \mathbf{H}_{\mathbf{r}^{(k)}}^{\!\top} \\
		\mathbf{H}_{\mathbf{r}^{(k)}} & \mathbf{0}_{6\times6}
	\end{pmatrix}
	\begin{pmatrix}
		\boldsymbol{\delta}^{*} \\
		\boldsymbol{\lambda}^{*}
	\end{pmatrix}
	=
	\begin{pmatrix}
		-\,2\Omega\,\mathbf{r}^{(k)} \\
		-\,h\bigl(\mathbf{r}^{(k)}\bigr)
	\end{pmatrix}
\end{equation}
解此线性方程组即可得到优化方向增量 $\boldsymbol{\delta}^{*}$ 以及对应的拉格朗日乘子 $\boldsymbol{\lambda}^{*}$。然后将旋转向量更新为
\begin{equation}
	\mathbf{r}^{(k+1)} = \mathbf{r}^{(k)} + \boldsymbol{\delta}^{*}\;
\end{equation}
并重复上述过程，直到增量范数足够小而收敛。通过这种 SQP 迭代，在每一步都满足（或逐步逼近）旋转矩阵的正交约束，并不断降低目标函数，最终得到满足 $R^\top R = I$ 的最优旋转矩阵解 $R^{*}$。


\subsection{平移向量 $\mathbf{t}$ 的求解}
在确定了旋转矩阵 $R$ 之后，平移向量 $\mathbf{t}$ 可以通过最小二乘闭式求解。由于上述代价函数在消去 $\mathbf{t}$ 后成为 $\mathbf{x}^\top \Omega \mathbf{x}$，这实际上等价于：对于任意给定的 $R$，都可直接找到使误差最小的 $\mathbf{t}$ 表达式。这由对原始未消元的目标函数关于 $\mathbf{t}$ 的偏导为零条件得到。具体而言，利用先前定义的 $A_i$ 和 $Q_i$ 矩阵，令 $\mathbf{r}=\operatorname{vec}(R)$ 为旋转的 9 维向量，对 $\mathbf{t}$ 求导并令梯度为零，可得到如下线性方程：
\begin{equation}
	\sum_{i=1}^{n} Q_i\bigl(A_i \mathbf{r}+\mathbf{t}\bigr)=\mathbf{0}_3
\end{equation}
其中 $A_i\mathbf{r}=R X_i$ 表示旋转后的第 $i$ 个空间点坐标在相机坐标系下的表示（以向量形式融入等式），$Q_i$ 则与该点的观测有关的权矩阵。将上式整理，可得到关于 $\mathbf{t}$ 的线性方程组：
\begin{equation}
	\Bigl(\sum_{i=1}^{n} Q_i\Bigr)\mathbf{t}
	=-\,\sum_{i=1}^{n} Q_i A_i \mathbf{r}
\end{equation}
在通常情况下，矩阵 $\sum_i Q_i$ 是非奇异的（这相当于所有点的方向约束提供了充分信息）。因此可以直接求解得到
\begin{equation}
	\mathbf{t}
	=-\,\Bigl(\sum_{i=1}^{n} Q_i\Bigr)^{-1}
	\sum_{i=1}^{n} Q_i A_i \mathbf{r}
\end{equation}
即 $\mathbf{t}$ 关于 $\mathbf{r}$ 为线性关系，可写为 $\mathbf{t}=P\mathbf{r}$。其中矩阵 $P=-(\sum_i Q_i)^{-1}(\sum_i Q_i A_i)$ 可以在给定所有观测点后预先计算。当利用上述 SQP 方法得到最终最优旋转 $\mathbf{r}^{*}$ 时，只需代入此公式即可得到对应的最优平移 $\mathbf{t}^{*}$。由于这一求解过程实质上是对原目标关于 $\mathbf{t}$ 的线性最小二乘优化，因而计算高效且解是全局最优的。值得一提的是，在实际实现中，不必每次迭代都重新计算 $\mathbf{t}$；通常可以在主迭代外层，当旋转收敛后再一次性求出最终 $\mathbf{t}$，或者在需要评估当前解的实际投影误差时临时计算相应的 $\mathbf{t}$ 值。

在确定了旋转矩阵 $R$ 之后，平移向量 $\mathbf{t}$ 可以通过最小二乘闭式求解。由于上述代价函数在消去 $\mathbf{t}$ 后成为 $\mathbf{x}^\top \Omega \mathbf{x}$，这实际上等价于：对于任意给定的 $R$，都可直接找到使误差最小的 $\mathbf{t}$ 表达式。这由对原始未消元的目标函数关于 $\mathbf{t}$ 的偏导为零条件得到。具体而言，利用先前定义的 $A_i$ 和 $Q_i$ 矩阵，令 $\mathbf{r}=\operatorname{vec}(R)$ 为旋转的 9 维向量，对 $\mathbf{t}$ 求导并令梯度为零，可得到如下线性方程：
\begin{equation}
	\sum_{i=1}^{n} Q_i\bigl(A_i \mathbf{r}+\mathbf{t}\bigr)=\mathbf{0}_3
\end{equation}
其中 $A_i\mathbf{r}=R X_i$ 表示旋转后的第 $i$ 个空间点坐标在相机坐标系下的表示（以向量形式融入等式），$Q_i$ 则与该点的观测有关的权矩阵。将上式整理，可得到关于 $\mathbf{t}$ 的线性方程组：
\begin{equation}
	\Bigl(\sum_{i=1}^{n} Q_i\Bigr)\mathbf{t}
	=-\,\sum_{i=1}^{n} Q_i A_i \mathbf{r}
\end{equation}
在通常情况下，矩阵 $\sum_i Q_i$ 是非奇异的，因此可以直接求解得到
\begin{equation}
	\mathbf{t}
	=-\,\Bigl(\sum_{i=1}^{n} Q_i\Bigr)^{-1}
	\sum_{i=1}^{n} Q_i A_i \mathbf{r}
\end{equation}

即 $\mathbf{t}$ 关于 $\mathbf{r}$ 为线性关系，可写为 $\mathbf{t}=P\mathbf{r}$。其中矩阵 $P=-(\sum_i Q_i)^{-1}(\sum_i Q_i A_i)$ 可以在给定所有观测点后预先计算。当利用上述 SQP 方法得到最终最优旋转 $\mathbf{r}^{*}$ 时，只需代入此公式即可得到对应的最优平移 $\mathbf{t}^{*}$。由于这一求解过程实质上是对原目标关于 $\mathbf{t}$ 的线性最小二乘优化。

然而，$R$ 与 $\mathbf{t}$ 之间存在一定的耦合关系。由于 $\mathbf{t}$ 是通过最小二乘法根据已确定的 $R$ 求解得到的，这意味着平移向量 $\mathbf{t}$ 的优化空间实际上是受到旋转矩阵 $R$ 的影响的。在优化过程中，旋转矩阵 $R$ 的变化直接决定了平移向量 $\mathbf{t}$ 的求解方式，这种耦合限制了平移向量的搜索空间，从而影响了 $\mathbf{t}$ 的进一步寻优。若 $R$ 的求解精度较低，或者在某些特定情况下，平移向量 $\mathbf{t}$ 的变化范围被压缩，使得平移的优化空间无法充分探索。后续在求解出的 6D 姿态上进行的优化算法能够进一步解决这个问题。



\section{RANSAC算法}
\label{sec:ransac_pnp}

在第~\ref{chap:attention_kpt} 章中，介绍了基于注意力机制的关键点预测方法。由于网络输出往往不可避免地夹杂显著噪声，部分关键点甚至完全失真，这些点即被视作异常点（离群点）。如果将其直接送入 SQPnP 算法进行 6D 姿态解算，结果会受到明显干扰。为抑制此类离群点的影响，本章采用 Fischler 和 Bolles 于 1981 年提出的 RANSAC算法，对模型参数进行鲁棒估计。RANSAC 通过在数据中重复随机抽取最小样本并拟合模型，再用先验设定的误差阈值 $\tau$ 将整体数据划分为内点和外点，从而在大比例异常值的场景下仍能可靠地找到全局最优解。

在本文的 3D–2D 关键点匹配任务中，将阈值 $\tau$ 设为像素尺度上的最大允许重投影误差；只有当重投影误差 $\varepsilon$ 满足 $\varepsilon<\tau$ 时，对应匹配才被视为内点, 这里设为了8个像素点，参考了第~\ref{chap:attention_kpt}章图~\ref{fig:SPEED+_kpts_err}, ~\ref{fig:Nauka_MLM_kpts_err}与图~\ref{fig:Starlink_kpts_err}的结果，平均误差位于8个像素点也占半数以上，即使通过该阈值的筛选剔除，也能保证绝大多数样本用充足冗余的点进行 PnP 的解算。期望置信度 $\alpha$ 指定在至少得到一次全内点样本的意义下希望达到的成功概率，这里设为了0.99，这是 RANSAC 系列算法大多采用的参数\cite{9399280, riu2022automatic}。表示理论上有 99 \% 把握至少抽到一次“全内点”样本。$s$ 表示拟合所需的样本大小，这里选择的是 $s=5$，但考虑到 PnP 算法通常最少需要 4 个点来求解，但为了保证一定冗余性并提高求解精度，这里额外再加 1 个点；最大迭代次数 $k_{\max}$ 则充当硬性上限，这里设置为10000，以保证算法能够有充足机会搜索到更优的解，同时也保证算法在最坏情况下也能于相对有限步内终止，不耗费过多时间。随着迭代进行，可根据当前内点比例 $\omega_{\text{best}}=\lvert\mathcal{I}_{\text{best}}\rvert/N_{\text{kpt}}$ 自适应地更新理论上满足置信度 $\alpha$ 的最少迭代次数
\begin{equation}
	N=\frac{\ln(1-\alpha)}{\ln\!\bigl(1-\omega_{\text{best}}^{\,s}\bigr)}
\end{equation}
其中 $N_{\text{kpt}}$ 为全部关键点对数量。当 $k\ge\min(N,k_{\max})$ 时即可安全停止并返回最佳模型。为了兼顾准确性与效率，我们同时维护当前最佳的内点集合 $\mathcal{I}_{\text{best}}$ 及其对应的总重投影误差 $E_{\text{best}}$，若新模型的内点数更多，或在内点数相同但误差更小时，则用其更新全局最佳结果。

图~\ref{fig:ransac_flowchart} 给出了 RANSAC 流程示意：输入匹配集 $\mathcal{I}_{3D},\mathcal{I}_{2D}$ 与超参数 $\alpha,\tau,k_{\max},s$ 后，首先初始化循环计数器 $k=0$、最佳内点比例 $\omega_{\text{best}}=0$、误差上限 $E_{\text{best}}=\infty$，并将理论最少迭代次数设为 $N=k_{\max}$；随后在每次循环中随机采样 $s$ 组匹配，调用 PnP 求解姿态向量 $(\mathbf{rvec},\mathbf{tvec})$，再对所有匹配计算重投影误差并据 $\tau$ 划分内外点，更新统计量 $\omega_i$ 与计数 $k$；当满足更新准则时刷新 $\mathcal{I}_{\text{best}}$、$\omega_{\text{best}}$、$E_{\text{best}}$ 以及由 $\omega_{\text{best}}$ 推导出的 $N$；最后检测 $k\!\ge\!k_{\max}$ 或 $k\!\ge\!N$ 的终止条件，若触发则输出当前最佳姿态与内点集。该自适应迭代策略既确保了置信度要求，又有效降低了平均计算量。
\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[node distance=18mm, >=Stealth, semithick, scale=0.8, transform shape]
		% -- 定义样式 --
		\tikzstyle{startstop} = [ellipse, draw, align=center, minimum width=25mm, minimum height=10mm]
		\tikzstyle{process} = [rectangle, draw, align=center, minimum height=12mm, minimum width=45mm]
		\tikzstyle{decision} = [diamond, aspect=2, draw, align=center, inner sep=1pt, minimum width=40mm, minimum height=14mm]
		\tikzstyle{data} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=60mm, minimum height=12mm, draw, align=center]
		
		% 开始
		\node[startstop] (start) {开始};
		
		% 输入框
		\node[data, below of=start, yshift=-5mm] (input) {
			输入
			$\mathcal{I}_{3D}$, $\mathcal{I}_{2D}$
			$\alpha$, $\tau$, $k_{\max}$, $s$
		};
		
		% 初始化：仅列出相关数学变量名称
		\node[process, below of=input, yshift=-2mm] (init) {
			初始化
			$k=0,\; \mathcal{I}_{\text{best}}=\emptyset,\; \omega_{\text{best}}=0,\; E_{\text{best}}=\infty,\; N=k_{\max}$
		};
		
		% 随机选取最小样本，并求解 PnP 得到 $tvec,\, rvec$
		\node[process, below of=init, yshift=-3mm] (sample) {
			随机选取最小样本\\
			求解 PnP得到$\mathrm{rvec}$,$\mathrm{tvec}$
		};
		
		% 根据阈值 $\tau$ 计算重投影误差，估计当前内点集
		\node[process, below of=sample, yshift=-3mm] (model) {
			计算关键点重投影误差\\
			按照阈值$\tau$估计内点集 $\mathcal{I}_{i,\text{new}}$
		};
		
		% 计算误差及统计内点比例，并更新迭代次数计数
		\node[process, below of=model, yshift=-3mm] (evaluate) {
			计算误差并统计 $\omega_i$\\
			$k \leftarrow k + 1$
		};
		
		% 判定是否更新最佳模型
		\node[decision, below of=evaluate, yshift=-14mm, text width=32mm] (better) {
			\scriptsize
			$|I_{i,\text{n}}| > |I_{\text{b}}|$ 
			\scriptsize 或 
			\scriptsize ($|I_{i,\text{n}}| = |I_{\text{b}}|$ 
			\scriptsize 且 $E_{i,\text{n}} < E_{\text{b}}$)
		};
		
		\node[process, right of=better, xshift=55mm, text width=40mm] (update) {
			\scriptsize
			$\mathcal{I}_{\text{best}} = \mathcal{I}_{i,\text{new}}$\\
			\scriptsize
			$\omega_{\text{best}} = \frac{|\mathcal{I}_{\text{best}}|}{N_{\text{kpt}}}$\\
			\scriptsize
			$N = \frac{\ln(1-\alpha)}{\ln(1 - \omega_{\text{best}}^s)}$
		};
		
		% 终止条件判定
		\node[decision, below of=better, yshift=-27mm, text width=30mm] (stop) {
			\scriptsize
			$k \ge k_{\max}$ 或 
			\scriptsize
			$k \ge N$ 或 
			\scriptsize
		};
		
		% 输出框
		\node[data, below of=stop, yshift=-20mm] (output) {
			输出\\
			$\mathrm{rvec}, \mathrm{tvec}$\\
			最佳内点集 $\mathcal{I}_{\text{best}}$
		};
		
		% 结束
		\node[startstop, below of=output, yshift=-8mm] (end) {
			结束
		};
		
		% 连线
		\draw[->] (start) -- (input);
		\draw[->] (input) -- (init);
		\draw[->] (init) -- (sample);
		\draw[->] (sample) -- (model);
		\draw[->] (model) -- (evaluate);
		\draw[->] (evaluate) -- (better);
		\draw[->] (better) -- node[above, xshift=3mm] {是} (update);
		\draw[->] (better) -- node[left] {否} (stop);
		\draw[->] (update) |- (stop);
		\draw[->] (stop) -- node[right] {是} (output);
		\draw[->] (output) -- (end);
		\coordinate (backLoop) at ($(sample.west)+(-6cm,0)$);
		\draw[->] (stop.west) node[above, xshift=-2.5mm]{否} -| (backLoop) -- (sample.west);
	\end{tikzpicture}
	\caption{RANSAC 算法流程图}
	\label{fig:ransac_flowchart}
\end{figure}

\begin{table}[h!]
	\centering
	\caption{RANSAC参数说明}
	\label{tab:ransac_params}
		\zihao{5} % 局部将表格内字号设置为五号
	\begin{tabular}{ccp{8cm}}
		\toprule
		符号 & 含义\\
		\midrule
		$\mathcal{I}_{3D}, \mathcal{I}_{2D}$ & 3D--2D（像素）点坐标集合 \\
		$\alpha$ & 期望的置信度 \\
		$\tau$ & 关键点重投影误差阈值 \\
		$k_{\max}$ & 最大迭代次数 \\
		$s$ & 最小样本大小 \\
		$k$ & 当前迭代次数 \\
		$N$ & 根据 $\alpha$ 和内点比例动态计算得到的最少迭代次数 \\
		$\omega_{\text{best}}$ & 当前最佳模型的内点比例 \\
		$E_{\text{best}}$ & 当前最佳模型的总误差或平均误差 \\
		$\mathbf{rvec}$ & 估计的旋转向量（Rodrigues形式） \\
		$\mathbf{tvec}$ & 估计的平移向量 \\
		\bottomrule
	\end{tabular}
\end{table}










\section{信赖域优化算法}

由于关键点噪声的干扰，加上 PnP 求解算法的一定局限。导致对于解算出的 6D 姿态会出现更大的偏差，有不少研究基于关键点重投影误差最小化对其进行优化以获得更为精确的解\cite{10297555,guo2024joint}。信赖域优化算法是一种基于信赖域思想的非线性优化方法。信赖域算法通过在每次迭代中限制步长范围，可可靠地求解约束优化问题，确保即使在大规模非线性约束条件下算法也能保持收敛性和高效性​\cite{wen2024augmented}。另外，TRO 针对复杂的目标函数优化，通过动态调整信赖域半径在全局搜索与局部模型近似之间取得平衡，既避免过大步长导致的发散，又防止过小步长陷入局部极值，从而实现对复杂目标的有效优化​\cite{asmtr}。基于上述特点，信赖域优化方法已成为解决诸如约束规划、非凸优化等难题的有力工具，在学术研究和工程实践中具有重要地位。
考虑到关键点重投影误差优化也是一种非线性优化问题,其目标函数的非凸。这里将 TRO 用于优化 6D 姿态。TRO 在每次迭代中，它通过构建当前点处目标函数的二次近似模型，并在一个限定的“信赖域”半径范围内求解该模型的极小值，从而获得试探步长。然后，通过计算目标函数实际值降低量与模型预测降低量的比值 $\rho_k$，判断该步长是否可信。如果 $\rho_k$ 值足够大（如达到预设阈值 $\eta$），则认为模型对实际函数的近似较好，接受该步长并更新当前解；否则，拒绝该步长（保持当前解不变）。无论步长是否被接受，算法都会根据 $\rho_k$ 的大小自适应地调整信赖域半径（如果步长效果理想则适当增大信赖域范围，以加快收敛；若步长效果不佳则缩小信赖域范围，以提高下一步迭代的可靠性）。如此迭代进行，直至满足收敛判据（例如梯度范数足够小或步长长度足够小），算法终止并得到最终优化结果。


\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[
		>=stealth,
		node distance=2.2cm,   % 节点垂直/水平距离
		every node/.style={font=\small},
		startstop/.style={
			ellipse,
			draw,
			align=center,
			minimum width=2.5em,
			minimum height=1.5em
		},
		process/.style={
			rectangle,
			draw,
			align=center,
			minimum width=6em,
			minimum height=2em
		},
		decision/.style={
			diamond,
			aspect=2,
			draw,
			align=center,
			inner sep=1pt,
			text width=9em,
			minimum height=3em
		}
		]
		
		% 开始
		\node (start) [startstop] {开始};
		
		% 初始化
		\node (init) [process, below of=start, yshift=-0.5cm] {
			初始化参数 $x_0$ 及信赖域半径 $\Delta_0$\\
			令 $\mathrm{nfev} = 0$
		};
		
		% 构建子问题
		\node (subprob) [process, below of=init, yshift=-0.5cm] {
			构建二次模型\\
			并求解信赖域子问题\\
			得到试探步长 $\mathbf{p}_k$
		};
		
		% 评估目标函数
		\node (eval) [process, below of=subprob, yshift=-0.5cm] {
			评估目标函数\\
			$\mathrm{nfev} \leftarrow \mathrm{nfev} + 1$\\
			计算实际下降与预测下降比值 $\rho_k$
		};
		
		% 判断步长可接受?
		\node (accept) [decision, below of=eval, yshift=-0.5cm] {
			$\rho_k \ge \eta$
		};
		
		% 接受步长
		\node (updateX) [process, right of=accept, xshift=3.2cm, yshift=-1.5cm] {
			接受步长:\\
			$x_{k+1} = x_k + \mathbf{p}_k$
		};
		
		% 拒绝步长 - 更改此处的xshift参数，从-3.2cm改为-4.5cm
		\node (rejectStep) [process, left of=accept, xshift=-3.5cm, yshift=-1.5cm] {
			拒绝步长:\\
			$x_{k+1} = x_k$
		};
		
		% 调整信赖域半径
		\node (radius) [process, below of=accept, yshift=-0.5cm] {
			根据 $\rho_k$\\
			调整信赖域半径 $\Delta_{k+1}$
		};
		
		% 终止条件
		\node (stopcond) [decision, below of=radius, yshift=-1.5cm, text width=10em] {
			$\mathrm{nfev} \ge \mathrm{nfev}_\mathrm{max}$\\
			或 $\|\nabla f\|_\infty \le \texttt{gtol}$\\
			或 $\|x_{k+1} - x_k\| \le \texttt{xtol}$
		};
		
		% 结束
		\node (stop) [startstop, below of=stopcond, yshift=-1.5cm] {
			结束
		};
		
		% 连线
		\draw[->] (start) -- (init);
		\draw[->] (init) -- (subprob);
		\draw[->] (subprob) -- (eval);
		\draw[->] (eval) -- (accept);
		
		\draw[->] (accept) -| node[anchor=south, near start]{是} (updateX);
		\draw[->] (accept) -| node[anchor=south, near start]{否} (rejectStep);
		
		\draw[->] (updateX) |- (radius);
		\draw[->] (rejectStep) |- (radius);
		
		\draw[->] (radius) -- (stopcond);
		
		% 如果满足终止条件则结束
		\draw[->] (stopcond) -- node[right, midway]{是} (stop);
		
		% 修改后的路径，改为-7增加左侧距离
		\draw[->] (stopcond) -- ++(-8,0) node[midway, above]{否} |- (subprob);
		
	\end{tikzpicture}
	\caption{信赖域优化算法流程图}
	\label{fig:TRO_flowchart}
\end{figure}



如图~\ref{fig:TRO_flowchart} 所示，算法从初始化开始：在当前点 $x_k$ 构建二次模型并求解信赖域子问题得到 $\mathbf{p}_k$，再通过 $\rho_k$ 判断是否接受步长并据此调整半径 $\Delta_k$。若满足任一终止条件，则输出最终解，否则进入下一次迭代。

$x_0$ 为初始参数向量，通常由上一阶段估计或启发式方法给出；$\Delta_0>0$ 为初始信赖域半径，表示局部二次模型被认为可信的范围，常根据变量尺度设定为经验值；$\eta$ 为步长接受阈值，用于控制试探步的可接受程度；$\rho_k$ 为实际下降量与预测下降量之比，用来衡量二次模型对真实目标函数的拟合质量；$\Delta_k$ 是当前信赖域半径，算法依据 $\rho_k$ 动态调节其大小；$\mathrm{nfev}_{\max}$ 为允许的最大函数评估次数，设为6000，以保证算法有充足的机会收敛至更优解，同时也保证了算法即使无法收敛也能在较短时间内结束；$\texttt{gtol}$ 为梯度无穷范数阈值；$\texttt{xtol}$ 为步长范数阈值，均设为 $1\times10^{-8}$，其量级大约是双精度浮点机器精度 ($\approx2.2\times10^{-16}$) 的平方根——足够小以保证求解精度，又不会因为阈值过于严苛而让迭代空转,当连续两次迭代的参数更新小于该值即认为收敛。

\section{RANSAC-TRO-SQPnP算法}
\label{sec:RANSAC-TRO-SQPnP:algorithm}

如图 \ref{fig:RANSAC-TRO-SQPnP-flow} 所示，RANSAC-TRO-SQPnP 算法将 RANSAC、SQPnP 和信赖域优化三个环节有机结合，以鲁棒地应对关键点检测中的异常点和噪声问题，从而获得高精度的 6D 姿态估计结果。具体来说，该流程主要包括以下三个步骤：

首先，对于输入的图像关键点的像素坐标及其对应的模型关键点的 3D 坐标，应用 RANSAC 算法进行内点筛选。RANSAC 随机抽取少量关键点对组成候选子集，并通过求解 PnP 对该子集进行姿态求解与重投影误差计算。经过多次迭代评估后，RANSAC 选择使重投影误差最小的子集作为内点集合，从而有效地识别并剔除图像关键点检测中的异常点，从而有效降低异常点对6D姿态求解的干扰。

然后，利用 RANSAC 得到的内点集合，采用 SQPnP 算法解算目标 6D 姿态。SQPnP 以关键点重投影误差最小化为优化目标，能够在关键点观测存在较大噪声的情况下仍然求解出较为精确的6D姿态。

最后，引入信赖域优化在 RANSAC 算法得出的内点集的基础上对 SQPnP 解算出的 进行进一步精细调整。TRO 通过将旋转和位移参数的优化过程解耦，在每次迭代中使用信赖域的测量。借助这种策略，TRO 能够在一定程度上缓解旋转与平移耦合对求解精度的不利影响，使算法在局部范围内对 6D 姿态估计进行更精细的修正，最终得到更高精度的 6D 姿态。

经过以上三个阶段的处理，RANSAC-TRO-SQPnP 算法能够可靠地过滤异常点干扰并降低关键点噪声影响，输出高精度且具有高鲁棒性的目标 6D 姿态估计结果。

\begin{figure}[htbp]
	\centering
	\begin{tikzpicture}[
		scale=0.6,
		terminator/.style={draw, ellipse, minimum width=3cm, minimum height=1cm, align=center},
		process/.style={draw, rectangle, minimum width=5.5cm, minimum height=1cm, align=center},
		io/.style={draw, trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=5.5cm, minimum height=1cm, align=center},
		arrow/.style={->, thick},
		node distance=1.8cm
		]
		\node[terminator] (start) {开始};
		\node[io, below=of start] (input) {输入：关键点， 像素坐标，\\ 关键点3D坐标， 相机内参};
		\node[process, below=of input] (ransac) {RANSAC 筛选内点集};
		\node[process, below=of ransac] (sqpnp) {SQPnP 解算6D姿态};
		\node[process, below=of sqpnp] (tro) {TRO 优化6D姿态};
		\node[io, below=of tro] (output) {输出：最终 6D 姿态};
		\node[terminator, below=of output] (end) {结束};
		
		\draw[arrow] (start) -- (input);
		\draw[arrow] (input) -- (ransac);
		\draw[arrow] (ransac) -- (sqpnp);
		\draw[arrow] (sqpnp) -- (tro);
		\draw[arrow] (tro) -- (output);
		\draw[arrow] (output) -- (end);
		
		% 额外连线：将 RANSAC 的右侧输出指向 TRO
		\draw[arrow] (ransac.east) -- ++(1.5,0) |- (tro.east);
	\end{tikzpicture}
	\caption{RANSAC-TRO-SQPnP 算法流程图}
	\label{fig:RANSAC-TRO-SQPnP-flow}
\end{figure}

\section{实验结果与分析}
%在第~\ref{chap:attention_kpt}章检测结果的基础上再结合本章的RANSAC-TRO 算法就可以得到空间非合作目标的6D姿态。本节首先介绍算法的参数设置，然后展示部分样本的6D姿态估计效果。最后在SPEED+数据集上进行PnP算法的消融对比，从而证明算法各部分的有效性。
\label{sec:RANSAC-TRO-SQPnP:ExperimentCompare}


\subsection{6D姿态解算的效果}
在第~\ref{chap:attention_kpt}章
本章特别选择了SPEED+和SPEED数据集的示例通过可视化关键点及其对应的6D姿态来展示其效果。其中红色的点代表关键点像素坐标的预测值。绿色的点代表关键点的像素坐标的真值。红色的框代表6D姿态估计的结果，绿色框代表6D姿态估计的真值。如图~\ref{fig:easy_demo}所示，除开第一个案例。其他案例几乎所有关键点像素坐标的预测值与真值几乎重合。而对于6D姿态，预测所有案例基本与真实值一致。即使是第一幅图。在图~\ref{fig:hard_demo}中，展示了光线更暗场景的情形，细节特征弱化，目标大多处于截断状态，部分特征缺失，还有背景叠加作为干扰。即使是这样很多案例关键点检测的效果也能实现几乎与真值重合。但是，当然也有不少案例关键点检测效果误差明显。然而这并不意味着6D姿态估计精度的误差会很明显，得益于本章的RANSAC-TRO SQPnP算法，在关键点噪声明显的情况下也能排除干扰逼近6D姿态真值。在这个过程中RANSAC算法部分也起了关键作用。如图~\ref{fig:ransac_demo}所示，绿色的为关键点的像素坐标真值，红色蓝色的点为预测值，其中蓝色的为外点，红色的为内点。可以看出外点的误差明显大于内点的误差，可以看出RANSAC算法在排除误差较大的点时所发挥的作用。通过这样的排除使得6D姿态解算过程的干扰得到降低从而得到了更高精度的解算结果。然而当异常点过多时，用于解算6D姿态的点过少也会使得估计的结果的误差较大，如图~\ref{fig:ransac_demo}第三个案例所示。
SPEED数据集还提供了真实的Tango卫星照片，但没有姿态标注。本章在图~\ref{fig:real_demo}中也可视化了本章在这些图像上的估计结果。由于合成数据到真实数据的风格显著差异。估计结果的精度明显降低。特别是关键点的预测，如果只从关键点分布来肉眼判断，很难识别出这是预测的Tango卫星的关键点。关键点检测网络的局限性凸显。但是仍有部分案例预测的结果看上去较为接近Tango卫星的实际6D姿态。这是本章算法对关键点较强噪声鲁棒性的体现。可以在一定程度上应对关键点预测性能大幅下降的情况。针对关键点检测网络的局限，未来可考虑使用无监督的学习方式。或者通过更真实的实物仿真构建数据集的方式来增强网络对真实数据的迁移能力。

\begin{figure}[!t] \centering \includegraphics[width=1\textwidth]{Img/easy_demo.pdf} \caption{SPEED+合成图像常规场景的估计结果可视化} \label{fig:easy_demo} \end{figure}

\begin{figure}[!t] \centering \includegraphics[width=1\textwidth]{Img/hard_demo.pdf} \caption{SPEED+合成图像光照过暗场景的估计结果可视化} \label{fig:hard_demo} \end{figure}

\begin{figure}[htbp] \centering \includegraphics[width=1\textwidth]{Img/ransac_demo.png} \caption{RANSAC算法排除外点的可视化} \label{fig:ransac_demo} \end{figure}

\begin{figure}[htbp] \centering \includegraphics[width=1\textwidth]{Img/real_demo.pdf} \caption{在SPEED真实图像上的6D估计结果的实际示例} \label{fig:real_demo} \end{figure}




\subsection{PnP 方法在 SPEED+数据集上的对比}
讨论完算法参数的设置，接下来将通过数据集测试算法，进行相关对比。
如第~\ref{chap:attention_kpt}章的图~\ref{fig:tango_demo}所示，该数据集场景丰富，目标截断，光照过暗，背景干扰等情形会对关键点检测网络造成更为显著的干扰，而本章的6D姿态解算方法正是为了提高算法对这些干扰的鲁棒性。因此决定在SPEED+数据集上对本章提出的RANSAC-TRO SQPnP算法进行验证。鉴于EPnP， P3P是始终都是文献中（包括近年来的文献)中常用的方法。因此选用其进行对比。
从表 \ref{tab:PnPCmp} 可见，与 EPnP 相比，SQPnP 在三个指标上都有明显提升，表明 SQPnP 的优化建模，优化求解手段对应关键点噪声更为鲁棒，使得求解精度明显高于 EPnP；RANSAC + SQPnP 的精度比单纯 SQPnP + LM 或 TRO 更优，说明异常点(外点)的存在确实会显著影响优化求解的过程，使其不能够收敛到理想的精度。如果首先选择去除外点则可以在不进行优化的情况下达到更优的精度。在 RANSAC-SQPnP 的基础上，对初始姿态进行 LM 和 TRO 两种后续优化时，LM 在 $score_{\text{ort}}^+$ 上略好一些，但 $score_{\text{pst}}^+$ 更差，导致最终 $score^+$ 下降；而 TRO 则在 $score_{\text{pst}}^+$ 与整体 $score^+$ 指标上优势更显著；这说明相对于 LM 优化，TRO 通过限制在信赖域上的优化，有利于局部更为精确的寻优从而在整体上达到更高的精度。以上对比说明了SQPnP算法的鲁棒性，也说明了RANSAC异常点提出机制以及TRO优化对于SQPnP算法求解精度提高的有效性。

\begin{table}[!htbp]
	\centering
	\caption{在SPEED+合成数据集上的PnP算法对比}
	\setlength{\tabcolsep}{4.7mm}
		\zihao{5} % 局部将表格内字号设置为五号
	{
		\begin{tabular}{lccc}
			\toprule
			方法 & $score_{\text{ort}}^+$ & $score_{\text{pst}}^+$ & $score^+$  \\ \midrule
			EPnP \citep{EPnP} & 0.02539 & 0.01356 & 0.03896 \\
			SQPnP \citep{terzakis2020consistently} & 0.02227 & 0.01247  & 0.03474 \\
			RANSAC SQPnP & 0.01877 & 0.00860  & 0.02737 \\
			LM \citep{lm} SQPnP & 0.02227 & 0.01446 & 0.03673 \\
			RANSAC-LM SQPnP & \textbf{0.01875} & 0.00865 & 0.02739 \\
			TRO \citep{trf} SQPnP & 0.02227 & 0.01251 & 0.03478 \\
			RANSAC-TRO SQPnP & 0.01878 & \textbf{0.00850} & \textbf{0.02728} \\ 
			\bottomrule
	\end{tabular}}
	\label{tab:PnPCmp}
\end{table}



\subsection{与其他空间非合作目标6D姿态估计方法的对比}
\label{sec:RANSAC-TRO-SQPnP:OthersCompare}
按照本文的方法架构，如第~\ref{chap:intro}的图~\ref{fig:6D_pose_estimation_archieture}所示，第~\ref{chap:attention_kpt}章已经完成了基于注意力机制的关键检测网络的开发，能够得出空间非合作目标的像素坐标并结合空间非合作目标标准6D姿态下的先验关键点的3D坐标，再通过本章提出的RANSAC-TRO SQPnP算法就能够解算出空间非合作目标的6D姿态。因此本节将对这两个阶段的步骤串联起来作为一套完整的空间非合作目标6D姿态估计方案与其他空间非合作目标6D姿态估计方法进行对比。
考虑到许多相关研究在SPEED/SPEED+数据集上进行了测试，本节也选用这两个数据集进行精度测试。为了验证本文从第\ref{chap:attention_kpt}章提出的关键点检测网络出发，再通过本章的6D姿态解算方法得出6D姿态估计的精度，将其与其他空间非合作目标6D姿态估计方法进行对比。评估指标采用第~\ref{chap:attention_kpt}章第~\ref{subsec:est_indicator}节中定义的标准，所有指标数值均为越小代表精度越高。

\subsection{SPEED数据集上的对比}

如表~\ref{tab:SPEED_Comparison}所示，本文所提出的方法在$err_{\text{T}}$与$err_{\text{ort}}^{\circ}$指标上分别达到了$0.1043 \text{ m}$与$1.4076^{\circ}$。从物理意义上看，这表示绝对平移误差为$0.1043 \text{ m}$，旋转误差为$1.4076^{\circ}$。在$err_{\text{T}}$指标与别的方法相比上不是很理想，在$err_{\text{ort}}^{\circ}$指标上精度适中。参数量在一定程度上反映了模型的复杂度，参数量越小，通常复杂度越低，越具备部署到功耗受限平台的潜力。考虑到本文方法的参数量远小于其他方法，且误差小于部分大参数量方法，具有明显优势。对于 SPEED+数据集中的 Tango 卫星（最大直径 $1.36\ \text{m}$），
本文算法给出的平移误差为 $0.1043\ \text{m}$，仅占目标最大直径的 $7.67\%$。
国际对接系统标准（International Docking System Standard, IDSS）\cite{IDSS_IDD_RevF_2022}在初始接触条件中规定的横向位置容差为
$0.10\ \text{m}$，可见该误差已处于其允许范围之内。
IDSS 还对姿态偏差给出了
$\lVert\text{pitch},\text{yaw}\rVert_{\text{vec}} \le 4^{\circ}$、
$\text{roll} \le 4^{\circ}$ 的要求\cite{IDSS_IDD_RevF_2022}，
而本文估计的旋转误差仅 $1.4076^{\circ}$，远低于该上限。

\begin{table}[htbp]
	\centering
	\caption{在SPEED合成数据集上6D空间非合作目标姿态估计方法的性能比较}
	\label{tab:SPEED_Comparison}
		\zihao{5} % 局部将表格内字号设置为五号
	\begin{tabular}{lccc}
		\toprule
		方法 & $err_{\text{T}}$ & $err_{\text{ort}}^{\circ}$ & 参数量(M) \\
		\midrule
		Hu et al.\citep{gerard2019segmentation} & 0.0730 & 0.9100 & $\sim$59.1 \\
		Chen et al.\citep{chen2019satellite} & \textbf{0.0320} & \textbf{0.4100} & $\sim$49.8 \\
		Sharma et al.\citep{sharma2019pose}    & 0.7832 & 8.4254 & - \\
		Proenca et al.\citep{9197244} & 0.1450 & 2.4900 & $\sim$11.4 - $\sim$42.8\\
		Lotti et al.\citep{lotti2022investigating} & 0.0340 & 0.5200 & 15.4 \\
		Wang et al.\citep{wang2022revisiting} & 0.0391 & 0.6638 & $\sim$47.8 \\
		Park et al.\citep{park2019towards} & 0.2090 & 2.6200 & 11.17 \\
		Piazza et al.\citep{piazza2021deep} & 0.1036 & 2.2400 & $\sim$36.1 \\
		Huan et al.\citep{huan2020pose} & 0.1823 & 2.8723 & $\sim$63.6 \\
		本文的方法 & 0.1043 & 1.4076 & \textbf{4.3} \\
		\bottomrule
	\end{tabular}
\end{table}

\subsection{SPEED+数据集上的对比}

相对于SPEED合成数据集而言，SPEED+合成数据集样本更丰富，场景更为多样化。这里将其与SPEED+合成数据集测试的其他方法进行比较
表\ref{tab:SPEEDplus_Comparison}展示了在SPEED+上各方法的详细对比。可见本文方法（小参数量）在旋转$\text{score}_{\text{ort}}^+$与位置综合评分$\text{score}^+$上取得较好结果，本文的方法能够以$4.3$M的参数量，$10.4 $GFLOPs 的计算复杂度达到$\text{err}_{\text{ort}}^{\circ}$指标$1.0760$，$\text{err}_{\text{T}}$指标$0.0459$，$\text{err}_{\text{ort}}^{\circ}$也就是旋转误差$1.076^{\circ}$，平移误差$0.0459$m。优于别人方法中的大部分方法。这进一步印证了本文采用的直接回归关键点的思路在轻量化网络架构的基础上再辅以注意力机制的改进能够较好地兼顾轻量化与精度。

为了更进一步证明本文方法架构的优势，这里增加了6D姿态估计第一阶段关键点检测网络的参数量，给出了中等参数量与大参数量的两个版本的方法，可以看出，精度进一步提升，对于大参数量级别的本文方法，在$\text{err}_{\text{ort}}^{\circ}$指标优于SPNv2($\phi=6$ GN)方法，虽然在$\text{err}_{\text{T}}$指标上不如SPNv2($\phi=6$ GN)方法但是整体性能指标$\text{score}^+$却优于SPNv2($\phi=6$ GN)，而且参数量与FLOPs却均小于SPNv2($\phi=6$ GN)。这进一步证明本文的方法在架构上也是具有优势。在应用中，只要平台的计算资源足够，可以通过扩大本文方法的参数量来获取更优越的6D姿态估计精度。
\begin{table}[htbp]
	\centering
	\caption{SPEED+合成数据集上空间非合作目标6D姿态估计方法的性能比较}
	\label{tab:SPEEDplus_Comparison}
	\setlength{\tabcolsep}{0.5mm}
		\zihao{5} % 局部将表格内字号设置为五号
	{
		\begin{tabular}{lcccccc}
			\toprule
			方法 & 参数量(M) & FLOPs(G) & $err_{\text{ort}}^{\circ}$ & $score_{\text{ort}}^+$ & $err_{\text{T}}$ & $score^+$ \\
			\midrule
			SPN\cite{sharma2019pose} & - & - & 7.7700 & - & 0.1600 & 0.1600 \\
			KRN\cite{park2019towards} & - & - & 3.6900 & - & 0.1400 & 0.0900 \\
			HigherHRNet \cite{higherhrnet} & $\sim 28.6\text{–}63.8$ & $\sim 74.9\text{–}154.3$ & 1.5100 & - & 0.0500 & 0.0400 \\
			P\'erez-Villar et al. \citep{perez2022spacecraft} & 190.1 & 487.8 & 1.4700 & 0.0256 & - & 0.0355 \\
			SPNv2($\phi$=3 GN) \cite{park2024robust} & 12.0 & 29.2 & 1.2240 & 0.0214 & 0.0560 & 0.0310 \\
			SPNv2($\phi$=6 GN) \cite{park2024robust} & 52.5 & 148.5 & 0.8850 & 0.0154 & \textbf{0.0310} & 0.0210 \\
			YOLOv8n-pose\cite{yolov8_ultralytics} & \textbf{3.2} & \textbf{9.1} & 2.1662 & 0.0378 & 0.0857 & 0.0542 \\
			YOLOv8s-pose\cite{yolov8_ultralytics} & 11.6 & 30.2 & 1.5764 & 0.0275 & 0.0524 & 0.0395 \\
			本文的方法 & 4.3 & 10.4 & 1.0760 & 0.0188 & 0.0459 & 0.0273 \\
			本文的方法（中等参数量） & 18.7 & 53.5 & 0.8078 & 0.0141 & 0.0533 & 0.0231 \\
			本文的方法（大参数量） & 47.2 & 145.5 & \textbf{0.6750} & \textbf{0.0118} & 0.0418 & \textbf{0.0189} \\
			\bottomrule
		\end{tabular}
	}
\end{table}




\section{本章小结}
\label{sec:RANSAC-TRO-SQPnP:conclusion}

本章面向空间非合作目标6D姿态测量过程中的关键点噪声及异常点干扰问题，提出了结合RANSAC、SQPnP与信赖域优化的RANSAC-TRO-SQPnP算法，实现了从关键点检测到高精度6D姿态估计的完整流程。首先，利用 RANSAC 算法对关键点的离群点进行鲁棒筛选，在含有较多异常关键点的情况下仍能有效避免因离群点导致的误差放大，输出质量较高的内点集合。随后，基于该内点集合采用 SQPnP 算法进行初步的 6D 姿态估计，通过序列二次规划最小化重投影误差，能够在关键点噪声较大的条件下稳健收敛至较优解。最后，由于在 SQPnP 中平移向量 $t$ 依赖当前旋转矩阵 $R$ 进行线性最小二乘求解，二者存在耦合而难以进一步细化，本章引入信赖域优化对已得到的 6D 姿态进行精细调整，通过在每次迭代设置合适的信赖域半径，分别对旋转和平移参数进行子问题求解和步长评估，从而在局部范围内实现更高精度的收敛。基于 SPEED/SPEED+ 等数据集的对比实验表明，RANSAC-TRO-SQPnP 在滤除异常点、抑制噪声以及耦合去除方面具备显著优势，有效提高了最终的旋转和位置信息精度。
